I will make 3 contract for 3 different NFT :

1. A basic NFT using ERC721 standard
2. Random IPFS hosted NFT
3. Dynamic SVG NFT

## Summary of the random IPFS NFT Part

The contract RandomIpfsNft is a contract that allows users to mint non-fungible tokens (NFTs) by paying a fee and making a request to a Chainlink VRF (Verifiable Random Function) to generate a random number. The NFTs represent a random breed of dog, with the breed being determined by the random number generated by the VRF. The contract is an implementation of the ERC721 standard for NFTs and also includes functionality from the VRFConsumerBaseV2 contract and the ERC721URIStorage contract. It is also Ownable, meaning it has an owner with special privileges. The contract keeps track of the NFTs that have been minted and the breed of each NFT using the s_tokenCounter and s_dogTokenUris variables, respectively. It also has several events that can be used to track the progress of NFT requests and minting.

<br>

### About VRF Interaction

The contract RandomIpfsNft uses a Chainlink VRF to generate random numbers. The VRF is an on-chain service that allows users to request random numbers in a verifiable and secure way. In this contract, the VRF is accessed through the VRFCoordinatorV2Interface contract, which is stored in the i_vrfCoordinator variable.

To request a random number, the contract calls the requestRandomWords function on the i_vrfCoordinator contract.

Once the requestRandomWords function is called, the VRF service generates a random number and returns it to the RandomIpfsNft contract through a callback function (uint256[] memory randomWords in the param of fulfillRandomWords function). The callback function is specified in the fulfillRandomWords function, which is defined in the VRFConsumerBaseV2 contract and overridden in the RandomIpfsNft contract.

The random number returned by the VRF is used to determine which breed of dog the NFT will represent. The contract uses a Breed enum to define the possible breeds of dog, and a mapping function to map the random number to a specific breed. The NFT is then minted using the mint function, which is a standard function defined in the ERC721 contract. The breed of the NFT and the address of the minter are recorded in the NFTMinted event.

<br>

### About ERC721URIStorage

The ERC721URIStorage contract is an extension of the ERC721 standard for non-fungible tokens (NFTs) that adds support for storing and retrieving Uniform Resource Identifiers (URIs) for each NFT. A URI is a string of characters that identifies a name or a resource on the Internet. In the context of NFTs, a URI might be used to point to a web page or other online resource that contains information about the NFT, such as an image or a description.

The ERC721URIStorage contract defines several functions for working with URIs, including setTokenURI, getTokenURI, and tokenURI. In the RandomIpfsNft contract, the ERC721URIStorage contract is used to store the URI for each NFT that is minted. The URI for a particular NFT is set using the setTokenURI function, which takes the token ID of the NFT and the URI as arguments. The URI for a particular NFT can be retrieved using the getTokenURI function, which takes the token ID of the NFT as an argument and returns the URI. The tokenURI function can also be used to retrieve the URI for a particular NFT, but it is an "anonymous" function that does not take any arguments and instead uses the msg.sender and msg.sig variables to identify the NFT.

<br>

### About IPFS And Pinata

the NFTs in the RandomIpfsNft contract are intended to represent images of different breeds of dogs. These images are stored in InterPlanetary File System (IPFS) and accessed using their IPFS hash, which is a unique identifier for a file stored in IPFS.  
Pinata is a service for storing and managing data on IPFS, which is a decentralized, peer-to-peer protocol for sharing and storing files. Pinata provides a user-friendly interface for uploading and managing files on IPFS and also offers a number of tools and features for developers.
We can use a service like Pinata to store an image on IPFS and obtain the IPFS hash for the image.

<br>
<br>

## Commands for Dependencies

```
yarn add --dev hardhat

yarn hardhat

yarn add --dev @typechain/ethers-v5 @typechain/hardhat @types/chai @types/node @types/mocha ts-node typechain typescript

yarn add --dev @openzeppelin/contracts

yarn add --dev @chainlink/contracts

 yarn add --dev @pinata/sdk

 yarn add --dev path

 yarn hardhat deploy --tags randomipfs,mocks
```

## Some line comments

```
module.exports = async ({getNamedAccounts, deployments}){}
```

In a Hardhat project, the getNamedAccounts and deployments functions are provided to the deployment script as part of the runtime environment.

Hardhat is a development environment for Ethereum that provides a set of tools and libraries for building, testing, and deploying Ethereum smart contracts. When you run a deployment script in a Hardhat project, Hardhat sets up a runtime environment that provides a number of utility functions and objects that are useful for working with Ethereum contracts.

The getNamedAccounts property is a function that can be used to get the Ethereum addresses of named accounts that are defined in the project's Hardhat configuration. The deployments property is an object that contains functions that can be used to deploy contract artifacts to the Ethereum blockchain.

This line of code is typically used at the beginning of a deployment script in a Hardhat project to set up the necessary dependencies for the script. The function that is exported will be called when the deployment script is run, and it will have access to the getNamedAccounts and deployments functions through the object that is passed as an argument.

```
const basicNft = await deploy("BasicNFT", {
    from: deployer,
    args: args,
    log: true,
    waitConfirmations: network.config.blockConfirmations || 1,
  });
```

In this code snippet, the deploy function is being used to deploy a contract to the Ethereum blockchain and call its constructor with the specified arguments. The deploy function is part of the deployments object in a Hardhat project, and it takes two parameters: the name of the contract to be deployed, and an array of arguments to be passed to the contract's constructor.

The code passes the following parameters to the deploy function:

"BasicNFT": This is the name of the contract to be deployed.

{ from: deployer, args: args, log: true, waitConfirmations: }: This is an object that contains additional options for the deployment. The from property specifies the Ethereum address of the account that will be used to deploy the contract, the args property is an array of arguments that will be passed to the contract's constructor, the log property specifies whether deployment logs should be printed to the console, and the waitConfirmations property specifies how many block confirmations to wait for before returning the deployed contract's address.

The deploy function returns a promise that is resolved with the deployed contract's address once the deployment is complete. This promise is being awaited using the await keyword, so the code will pause until the deployment is complete and the contract's address is returned.
